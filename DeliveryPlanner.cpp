#include "provided.h"
#include <vector>
using namespace std;

class DeliveryPlannerImpl
{
  public:
    DeliveryPlannerImpl(const StreetMap* sm);
    ~DeliveryPlannerImpl();
    DeliveryResult generateDeliveryPlan(
        const GeoCoord& depot,
        const vector<DeliveryRequest>& deliveries,
        vector<DeliveryCommand>& commands,
        double& totalDistanceTravelled) const;
  private:
    const StreetMap* m_streetMap;        // Pointer to a fully-constructed and loaded StreetMap object
    
    string angleToProceedDir(double angle) const;       // Returns the direction based on the input angle for a Proceed cmd
    string angleToTurnDir(double angle) const;          // Return the direction based on the input angle for a Turn cmd
};

DeliveryPlannerImpl::DeliveryPlannerImpl(const StreetMap* sm)
{
    m_streetMap = sm;           // Pointer to a fully-constructed and loaded StreetMap object
}

DeliveryPlannerImpl::~DeliveryPlannerImpl()
{
}

DeliveryResult DeliveryPlannerImpl::generateDeliveryPlan(
    const GeoCoord& depot,
    const vector<DeliveryRequest>& deliveries,
    vector<DeliveryCommand>& commands,
    double& totalDistanceTravelled) const
{
      // First, reorder the order of delivery requests to optimize/reduce the total travel distance
    DeliveryOptimizer optimizer(m_streetMap);
    double oldCrowDistance, newCrowDistance;
      // Cast the deliveries vector to a non-const vector optimizedDeliveries
    vector<DeliveryRequest> optimizedDeliveries = const_cast <const vector<DeliveryRequest>&> (deliveries);
    optimizer.optimizeDeliveryOrder(depot, optimizedDeliveries, oldCrowDistance, newCrowDistance);
    
    totalDistanceTravelled = 0;         // Reset the total Distance Travelled to 0
    
    
      // Then, generate point-to-point routes between the depot to each successive optimized delivery point, then back to the depot (using the PointToPointRouter class)
    PointToPointRouter router(m_streetMap);
    GeoCoord prev = depot;
    vector<list<StreetSegment>> totalRoute;     // Vector to hold the route for each movement
    list<StreetSegment> route;                  // List to hold the route for each movement
    double currTravelDistance;                  // Travel distance for each movement, will be added to total dist
    
      // For every movement to a new location, generate a list of StreetSegments to follow. Push onto a larger list
    vector<DeliveryRequest>::iterator delivery = optimizedDeliveries.begin();
    while (delivery != optimizedDeliveries.end())
    {
        DeliveryResult result = router.generatePointToPointRoute(prev, delivery->location, route, currTravelDistance);       // Generate route
        
          // Check to make sure the point to point route was generated successfully
        if (result == NO_ROUTE || result == BAD_COORD)
            return result;
        
        totalDistanceTravelled += currTravelDistance;
        
          // Add the route for this movement to the vector for all routes
        totalRoute.push_back(route);
        
        //totalDistanceTravelled += currTravelDistance;       // Update the totalDistanceTravelled
        prev = delivery->location;                          // Update prev
        delivery++;                           // Increment iterator to next DeliveryRequest
    }
    
      // prev should be the GeoCoord of the last DeliveryRequest now. We need to go back to the depot.
    DeliveryResult result = router.generatePointToPointRoute(prev, depot, route, currTravelDistance);       // Generate route
    
      // Check to make sure the point to point route was generated successfully
    if (result == NO_ROUTE || result == BAD_COORD)
        return result;
    
    totalRoute.push_back(route);                        // Add the route for this movement to the vector for all routes
    totalDistanceTravelled += currTravelDistance;       // Update the totalDistanceTravelled, for the final time
    
      /* For each sequence of point-to-point StreetSegments generated by PointToPointRouter in the previous step, generate a sequence of DeliveryCommands representing instructions to the delivery robot. This involves:
      o Converting the sequence of StreetSegments produced by the PointToPointRouter class (e.g., from the depot to the first delivery coordinate, or from the Nth to the N+1st delivery coordinate, or from the last delivery coordinate back to the depot) into one or more proceed or turn DeliveryCommands.
      o After generating the proceed and turn DeliveryCommands to get to the robot to the next delivery location, generate a deliver DeliveryCommand indicating that a food item should be delivered at that location. */
    
    delivery = optimizedDeliveries.begin();     // Keeps track of which delivery
          // For each sequence of point-to-point StreetSegments...
    for (int i = 0; i < totalRoute.size(); i++)
    {
            // Generate a sequence of DeliveryCommands representing instructions to the delivery robot
        list<StreetSegment> currRoute = totalRoute[i];      // Current route for the current movement to delivery or depot
            
            // If the delivery location is AT the depot, simply generate a delivery command instantly and continue
        if (currRoute.empty())
        {
            DeliveryCommand instantDeliver;
            instantDeliver.initAsDeliverCommand(delivery->item);
            commands.push_back(instantDeliver);
            delivery++;
            continue;
        }
            
            // Process each StreetSegment
        list<StreetSegment>::iterator itr = currRoute.begin();
        while (itr != currRoute.end())
        {
                // First, make a proceed command for the start of this Street
            StreetSegment seg = *itr;
            string currStreet = seg.name;
            DeliveryCommand proceedCmd;
            string proceedDir = angleToProceedDir(angleOfLine(seg));       // Compute direction for Proceed command
            double dist = distanceEarthMiles(seg.start, seg.end);   // Compute distance for first segment of Proceed command
            proceedCmd.initAsProceedCommand(proceedDir, seg.name, dist);
                
            if ( itr++ == currRoute.end() ) { break; }              // Move on to the next segment. Break if we are done.
                
            while ( itr->name == proceedCmd.streetName() )          // While the next Segment is the same street
            {
                double nextDist = distanceEarthMiles(itr->start, itr->end);     // Calculate the next segment's distance
                proceedCmd.increaseDistance(nextDist);      // Increase the distance of the Proceed command
                if ( itr++ == currRoute.end() ) { break; }  // Move on to the next segment. Break if we are done.
            }
                
            commands.push_back(proceedCmd);                 // Push the Proceed command onto commands
                  // Check that we have not reached the destination already before turning
            if (itr != currRoute.end())
            {
                    // After the while loop, we are done with the street, so now we need to turn
                list<StreetSegment>::iterator previous = std::prev(itr);   // Iterator to previous StreetSegment (last of Proceed command
                double turnAngle = angleBetween2Lines(*previous, *itr);
                    // If the angle is not between 1 and 359, inclusive, do not generate a turn command, and instead just proceed
                if (turnAngle < 1 || turnAngle > 359)
                    continue;               // By continuing, we are starting the while loop over, thus generating a Proceed
                    
                    // If we did not continue in the if statement above, generate a turn command
                DeliveryCommand turnCmd;
                string turnDir = angleToTurnDir(turnAngle);
                turnCmd.initAsTurnCommand(turnDir, itr->name);
                commands.push_back(turnCmd);
            }
        }
            
            // Check to see that the robot is delivering something and not returning to the depot...
        if (i != totalRoute.size() - 1)
        {
                // Generate a deliver DeliveryCommand indicating that a food item should be delivered at that location
            DeliveryCommand deliver;
            deliver.initAsDeliverCommand(optimizedDeliveries[i].item);
            commands.push_back(deliver);
        }
        delivery++;         // Move on to the next delivery
    }
    
    return DELIVERY_SUCCESS;        // If we got here, we successfully delivered
}

string DeliveryPlannerImpl::angleToProceedDir(double angle) const
{
    if (angle >= 0 && angle < 22.5)
        return "east";
    else if (angle >= 22.5 && angle < 67.5)
        return "northeast";
    else if (angle >= 67.5 && angle < 112.5)
        return "north";
    else if (angle >= 112.5 && angle < 157.5)
        return "northwest";
    else if (angle >= 157.5 && angle < 202.5)
        return "west";
    else if (angle >= 202.5 && angle < 247.5)
        return "southwest";
    else if (angle >= 247.5 && angle < 292.5)
        return "south";
    else if (angle >= 292.5 && angle < 337.5)
        return "southeast";
    else
        return "east";
}

  // PRECONDITION: Angle must be between 1 and 359 degrees, inclusive
string DeliveryPlannerImpl::angleToTurnDir(double angle) const
{
    if (angle >= 1 && angle < 180)
        return "left";
    else
        return "right";
}


//******************** DeliveryPlanner functions ******************************

// These functions simply delegate to DeliveryPlannerImpl's functions.
// You probably don't want to change any of this code.

DeliveryPlanner::DeliveryPlanner(const StreetMap* sm)
{
    m_impl = new DeliveryPlannerImpl(sm);
}

DeliveryPlanner::~DeliveryPlanner()
{
    delete m_impl;
}

DeliveryResult DeliveryPlanner::generateDeliveryPlan(
    const GeoCoord& depot,
    const vector<DeliveryRequest>& deliveries,
    vector<DeliveryCommand>& commands,
    double& totalDistanceTravelled) const
{
    return m_impl->generateDeliveryPlan(depot, deliveries, commands, totalDistanceTravelled);
}
